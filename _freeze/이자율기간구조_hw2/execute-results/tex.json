{
  "hash": "c8dcf85e73fba41cd39a9f2fd40e4927",
  "result": {
    "engine": "knitr",
    "markdown": "# 이자율기간구조 과제2 {.unnumbered}\n\n## Problem 1\n\n한 제조업체의 재무담당자가 usd 100 million 에 달하는 운전자본 working capital 을 3개월 정도 repo 시장에 투자하여 이익을 취하고자 한다.\n\n기간은 2020년 1월 15일(현재, 포함)에 시작하여 2020년 4월 15일(불포함)이 환매일이다. 즉 재무담당자는 91일 동안 daily SOFR 를 얻게 된다.\n\n그러나 최근 SOFR 의 하락세가 고민이 되어 투자금의 절반인 50 million 은 2020년 4월 만기인 3개월 SOFR 선물을 매수하여 수익 금리를 고정하는 효과를 가지려고 한다.\n\n기간 내내 금리가 1bp 하락한다면, act/360 기준으로 회사는 얼마의 손해가 발생하는가?\n\n이 절반에 대하여 SOFR 선물로 헤지를 한다면 몇 개의 선물 계약을 해야할지 본인의 계산을 쓰세요.\n\n### Answer\n\n전체 노출액 중 절반은 정확히 헷지하였으므로, 기간 중 노출액은 50mUSD입니다.\n\n노출기간은 91일이므로, **회사의 손해**는 $50,000,000\\times 0.0001\\times\\frac{91}{360}=1263.889USD$\n\nSOFR선물은 (100-r)로 호가하며, 1bp에 대해 25$만큼 변동합니다.\n\n따라서, 손실액만큼 SOFR선물에서 이익이 발생하도록 하려면 $\\frac{1263.889}{25}=50.56$, **약 51계약 매수**해야합니다.\n\n## Problem 2\n\n다음의 표는 2020년 6월 5일 ICE에서 가져온 usd스왑데이터이다. 편의상 각 스왑금리는 연 1회 지급한다고 하자. 우리는 bootstrapping 기법을 이용하여 이 스왑금리들을 할인율곡선 또 는 현물이자율 곡선으로 변환할 수 있다.\n\n이 문제에서는 그와 달리 매해 말 지급부담을 지니고 있는 은행 A를 고려한다. 이 은행은 현 시점에서 floating rate notes 변동금리부채권과 스왑을 매수하여 이 지급부담을 맞추려고 한다. 이때 변동금리부채권과 스왑의 액면값들을 구하는 것을 reverse bootstrapping 이라 한다. 보다 정확히 다음의 구조를 고려하자.\n\n- 각 FRN은 $N_1, ... , N_6$의 액면을 가지고 있으며 이들은 i번째 해의 말까지 매년 $N_i$ 에 해당하는 변동금리를 지급하고 i번째 해의 말에는 액면 $N_i$ 도 지급한다.\n- 각 스왑의 액면 역시 $N_i$이며 A는 floating rate payer이다. 즉 i번째 해의 말까지 매년 $N_i$에 해당하는 변동금리를 거래상대방에게 지급한다. 역으로 거래상대방은 매해 말 $N_is_i$ 을 지불한다. 여기에서 $s_i$는 i 만기 스왑금리이다.\n\n$N_1,...,N_6$를 구하고 소수점 네째자리까지 리포트하시오.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nswap <- tibble(tenor=c(1:6),\n               rate=c(0.307,0.299,0.346,0.424,0.517,0.614))\nswap\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 2\n  tenor  rate\n  <int> <dbl>\n1     1 0.307\n2     2 0.299\n3     3 0.346\n4     4 0.424\n5     5 0.517\n6     6 0.614\n```\n\n\n:::\n:::\n\n\n\n### Answer\n\n## Problem 3\n\n미 재무부에서 발표하는 일별 par yield 데이터를 찾되, 2024년 1월부터 5월까지 매월 첫번째 일자의 커브를 구하시오. 그리고 이 5개의 금리 커브에 대하여 Nelson-Siegel-Svensson 모형을 적용하여 본인이 구한 최선의 fitted curve를 리포트하시오. 1개월 금리부터 30년 금리까지 데이터 전체를 활용하시오.\n\n여기서 정답은 없으니, 본인이 적절한 초기값 및 제약식을 넣어 문제를 푸세요.\n\n### Answer\n\n먼저, **미 재무부의 daily par yield** 데이터를 이용하여 산출한 매월 첫번째 일자의 커브는 아래와 같습니다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuspar <- tibble()\nuspar <- read_csv(\"investment_hw/usparyield.csv\") %>% \n  arrange(Date) %>% \n  mutate(year=substr(Date,7,10),\n         month=substr(Date,1,2)) %>% \n  group_by(year,month) %>% \n  slice(1) %>% \n  pivot_longer(cols = contains(\" \"),values_to = \"par\", names_to = \"time\") %>% \n  mutate(maturity=c(1,2,3,4,6,12,24,36,60,84,120,240,360)/12) %>% \n  ungroup()\n\nggplot(uspar,aes(x=maturity,y=par,colour=month))+\n  geom_line()+\n  theme_bw()\n```\n:::\n\n\n\n다음으로, **NSS모형을 이용한 최적 fitted curve**를 구해보겠습니다.\n\n::: {.callout-note title=\"Nelson-Siegel-Svensson Model\"}\nNSS모형은 instantaneous forword rate를 추정하는 대표적인 모형으로, 3개의 factor와 6개의 parameter($\\beta_0\\sim\\beta_3, \\tau_1\\sim\\tau_2$)를 이용합니다.\n\n$$f(t)=\\beta_0+\\beta_1e^{-\\frac{t}{\\tau_1}}+\\beta_2\\frac{t}{\\tau_1}e^{-\\frac{t}{\\tau1}}+\\beta_3\\frac{t}{\\tau_2}e^{-\\frac{t}{\\tau_2}}$$\n\n이를 통해 continuous-compounding spot rate curve를 추정할 수 있습니다.\n\n$$r(t)=\\beta_0+\\beta_1\\frac{1-e^{-\\frac{t}{\\tau_1}}}{\\frac{t}{\\tau_1}}+\\beta_2[\\frac{1-e^{-\\frac{t}{\\tau_1}}}{\\frac{t}{\\tau_1}}-e^{-\\frac{t}{\\tau_1}}]+\\beta_3[\\frac{1-e^{-\\frac{t}{\\tau_2}}}{\\frac{t}{\\tau_2}}-e^{-\\frac{t}{\\tau_2}}]$$\n:::\n\n저는 **최적 fitted curve를 시뮬레이션을 통해 산출**할 예정입니다.\n\n먼저, 초기값을 $\\beta_0=30y\\;\\;par\\;\\;rate,\\;\\;\\;\\beta_1=1m\\;\\;par\\;\\;rate-\\beta_0$ 및 $\\beta_{2,3},\\;\\tau_{1,2}$는 $(-5,\\;5)$ 범위의 Uniform dist. random number로 설정하겠습니다.\n\n해당 초기값에 따라 constraint condition을 기준금리의 변동폭을 고려하여 25bp, $|\\beta_0+\\beta_1-1m\\;\\;par\\;\\;rate|<0.25$로 설정하고 finite difference method(optim fn. in R)를 통해 최적해를 산출합니다.\n(tau와 beta는 별도의 제약식 없이 진행하였습니다.)\n\n이러한 방식을 1,000번 반복하는 Monte-carlo simulation을 통해 1,000개의 최적해를 산출하고, 1,000개의 NSS rate curve에서 MSE가 가장 낮은 curve를 최적 fitted curve로 선정하겠습니다.\n\n이를 구현하기 위한 **R코드 및 24년 1~5월의 fitted curve는 아래와 같습니다.**\n\n#### 1. NSS Model 함수\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (nelson_siegel) return NSS model rates for given parameters\n# maturity : vector of year maturity\n# params : vector of NSS medel 6 parameters, beta0 to tau2\n\nnelson_siegel <- function(maturity, params){\n  \n  # parameters \n  beta0 = params[1]\n  beta1 = params[2]\n  beta2 = params[3]\n  beta3 = params[4]\n  tau1  = params[5]\n  tau2  = params[6]\n  \n  # function \n  beta0 + \n    beta1 * (1 - exp(-maturity/tau1)) / (maturity/tau1) + \n    beta2 * ((1 - exp(-maturity/tau1)) / (maturity/tau1) - exp(-maturity/tau1)) + \n    beta3 * ((1 - exp(-maturity/tau2)) / (maturity/tau2) - exp(-maturity/tau2)) \n  \n}\n```\n:::\n\n\n\n#### 2. NSS 최적해 산출 함수(finite difference method)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (optim_nelson_siegel) return optimal tibble for given term-structure,\n#                       using finite difference method\n# maturity : vector of year maturity\n# term_sturucture : vector of real spot rate, order to maturity, omit %\n\noptim_nelson_siegel <- function(term_structure = NULL, maturity = NULL, params = rep(0.1, 6),\n                                contraint_threshold = 0.1, tau_threshold = 10, beta_threshold = 30){\n  \n  loss_function <- function(params){\n    \n    # parameters \n    beta0 = params[1]\n    beta1 = params[2]\n    beta2 = params[3]\n    beta3 = params[4]\n    tau1  = params[5]\n    tau2  = params[6]\n    \n    # contraints\n    contraint = abs(beta0 + beta1 - term_structure[1])\n    \n    if(contraint > contraint_threshold ){\n      return(NA)\n    }\n    \n    # if(tau1 > tau_threshold | tau2 > tau_threshold){\n    #   return(NA)\n    # }\n    # \n    # if(beta2 > beta_threshold | beta3 > beta_threshold ){\n    #   return(NA)\n    # }\n    \n    sum(\n      (term_structure - beta0 - \n         beta1 *  (1 - exp(-maturity/tau1)) / (maturity/tau1) -\n         beta2 * ((1 - exp(-maturity/tau1)) / (maturity/tau1) - exp(-maturity/tau1)) - \n         beta3 * ((1 - exp(-maturity/tau2)) / (maturity/tau2) - exp(-maturity/tau2)) \n      )^2)\n    \n  }\n  \n  # set initial values for to beta0 and beta1 that respect the contraint \n  # beta0 is long-term rate & beta1 is short-term rate minus beta0\n  params = c(term_structure[length(term_structure)],\n             term_structure[1]-term_structure[length(term_structure)],\n             params[3:6] )\n               \n  # beta0 & beta1 is equal to (short-term rate)/2\n  # params = c(term_structure[1]/2,term_structure[1]/2,params[3:6] )\n  \n  # minimization of the loss function \n  optimization = optim(params, loss_function)\n  \n  # optimal parameters \n  optim_params = c(beta0 = optimization$par[1], \n                   beta1 = optimization$par[2], \n                   beta2 = optimization$par[3],\n                   beta3 = optimization$par[4],\n                   tau1  = optimization$par[5], \n                   tau2  = optimization$par[6])\n  \n  # fitted value from Nelson-Siegel base function \n  fitted_values = nelson_siegel(maturity, optim_params)\n  \n  # compute the mean square error\n  mse_fit = sd(fitted_values - term_structure, na.rm = TRUE)\n  \n  # output \n  dplyr::tibble( \n    maturity = list(maturity),\n    term_structure = list(term_structure),\n    start_params = list(params),\n    optim_params = list(optim_params),\n    fit = list(fitted_values),\n    mse = mse_fit\n  )\n} \n```\n:::\n\n\n\n#### 3. Uniform dist. random number 생성\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (random_params) return random number follows an uniform distribution\n# n.params: number of parameter to generate \n# params.min: for random generation, minimum parameter\n# params.max: for random generation, maximum parameter\n# seed: to control randomness \n\nrandom_params <- function(n.params = 1, params.min = 0, params.max = 5, seed = 1){\n  \n  set.seed(seed)\n  \n  runif(n.params, params.min, params.max)\n  \n}\n```\n:::\n\n\n\n#### 4. Monte-carlo simulation (Calibration)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (calibrate_nelson_siegel) return n-times \"optim_nelson_siegel\" outputs\n#                           using Monte-carlo simulation for random 3 parameters(beta2 to tau2)\n# n: number of simulations \n# params.min: for random generation, minimum parameter\n# params.max: for random generation, maximum parameter\n# verbose: disply progress in the importation.\n\ncalibrate_nelson_siegel <- function(object, n = 100, params.min = -5, params.max = 5, \n                                    contraint_threshold = 0.01, verbose = TRUE ){\n  \n  # initialize the parameters \n  term_structure = object$term_structure[[1]]\n  maturity = object$maturity[[1]]\n  \n  # list containing all the simulations \n  simulations = list()\n  \n  # safe version to avoid errors if we made many simulations\n  safe_optim = purrr::safely(optim_nelson_siegel)\n  \n  for(i in 1:n){\n    \n    # generate a random seed\n    random_seed = mean(random_params(10, 0, 100000, seed = i))\n    \n    # generate random parameters \n    random_params = random_params(6, params.min, params.max, seed = random_seed)\n    \n    simulations[[i]] = safe_optim(term_structure  = term_structure, maturity = maturity, params = random_params, contraint_threshold = contraint_threshold)$result\n    \n    if( verbose &(i%%50 == 0)){message(\"Simulations: \", i, \"/\", n)}\n    \n  }\n  \n  # unique dataset for all the simulation\n  simulations_df = dplyr::bind_rows(simulations) \n  \n  # add the initial object\n  simulations_df = dplyr::bind_rows(object, simulations) \n  \n  # index for the simulations \n  simulations_df = dplyr::mutate(simulations_df, n = 1:nrow(simulations_df)) \n  \n  return(simulations_df)\n  \n}\n```\n:::\n\n\n\n#### 5. Optimal fitted curve 산출 및 시각화\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (optimal_params_ns) summarize of all above, return optimal result minimize MSE from n-times simulation.\n# term_structure = NULL\n# maturity = NULL\n# n = 1000\n# params.init = rep(0.1, 6)\n# params.min = -5\n# params.max = 5\n# contraint_threshold = 0.1\n# label = NULL (label for the plot)\n# verbose = TRUE\n\noptimal_params_ns <- function(term_structure = NULL, maturity = NULL, \n                              n = 1000, params.init = rep(0.1, 6), params.min = -5, params.max = 5,\n                              contraint_threshold = 0.1, label = NULL, verbose = TRUE){\n  \n  # first fit \n  first_fit_ns = optim_nelson_siegel(term_structure = term_structure, maturity = maturity, params = params.init)\n  \n  # simulations \n  sim_fit_ns = calibrate_nelson_siegel(first_fit_ns, n = n, params.min = params.min, params.max = params.max, contraint_threshold = contraint_threshold)\n  \n  # best parameters \n  df_optim_params = sim_fit_ns[which(sim_fit_ns$mse == min(sim_fit_ns$mse, na.rm = TRUE)),]\n  \n  \n  # setting the title of the plot \n  if(!is.null(label) & is.character(label)){\n    \n    plot_title = paste0(\"Fitted Nelson-Siegel-Svensonn vs Real Value \", \"(\", label, \")\" )\n    \n  } else {\n    \n    plot_title = \"Fitted Nelson-Siegel-Svensonn vs Real Value\"\n  }\n  \n  \n  # plot of fitted vs real values \n  plot_df =  dplyr::inner_join(\n    dplyr::tibble(\n      t = maturity,\n      pred = df_optim_params$fit[[1]]\n    ),\n    dplyr::tibble(\n      t = maturity,\n      real = term_structure\n    ),\n    by = \"t\"\n  ) \n  \n  # Plot Real value vs Fitted Values \n  plot_ns = plot_df %>%\n    mutate(label = paste0(\"T = \", round(t, 3)))%>%\n    ggplot()+\n    geom_point(aes(t, pred), color = \"red\", size = 2, alpha = 0.8) +\n    geom_point(aes(t, real), color = \"black\", alpha = 0.5)+\n    geom_line(aes(t, pred), color = \"red\", size = 1) +\n    geom_line(aes(t, real), color = \"black\", linetype = \"dashed\") +\n    geom_label(aes(t+1, real-0.001, label = label), size = 1.5)+\n    theme(axis.text.x = element_text(angle = 25, face = \"bold\", size = 7), \n          axis.text.y = element_text(face = \"bold\"), \n          axis.title  = element_text(face = \"bold\"),\n          plot.title  = element_text(face = \"bold\"),\n          plot.subtitle = element_text(face = \"italic\"),\n          plot.caption = element_text(face = \"italic\"),\n          panel.grid.major.x = element_line(colour=\"grey60\", linetype=\"dotted\"),\n          panel.grid.minor.x = element_blank(),\n          panel.grid.major.y = element_line(colour=\"grey60\", linetype=\"dotted\"),\n          legend.text = element_text(face = \"italic\", size = 5),\n          legend.title = element_text(face = \"bold\"),\n          legend.position = \"top\" ) +\n    scale_x_continuous(breaks=c(0, 0.5, 1,2,3,4,5,7,10,15, 20, 25, 30))+\n    ggtitle(plot_title, subtitle = \"Fitted Value in Red and Real Values in Black\" )+\n    xlab(\"Maturities\")+\n    ylab(\"\") + \n    labs(caption = paste0(\"Mean Squared Error of the Fit: \", round(df_optim_params$mse, 6)))+\n    theme_bw()\n  \n  \n  \n  # output \n  structure(\n    list(\n      optim_params = tibble( beta0=df_optim_params$optim_params[[1]][1],\n                             beta1=df_optim_params$optim_params[[1]][2],\n                             beta2=df_optim_params$optim_params[[1]][3],\n                             beta3=df_optim_params$optim_params[[1]][4],\n                             tau1=df_optim_params$optim_params[[1]][5],\n                             tau2=df_optim_params$optim_params[[1]][6]),\n      plot_ns = plot_ns,\n      simulations = sim_fit_ns,\n      df_optim = df_optim_params\n      \n    )\n  )\n  \n}\n```\n:::\n\n\n\n#### Result\n\n앞서 도식화한 **24년 1~5월의 US par-yield curve**에 위 방법을 적용하여 **각각 모델링한 fitted curve는 아래와 같습니다.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuspar_jan <- uspar %>% filter(month==\"01\")\nuspar_feb <- uspar %>% filter(month==\"02\")\nuspar_mar <- uspar %>% filter(month==\"03\")\nuspar_apr <- uspar %>% filter(month==\"04\")\nuspar_may <- uspar %>% filter(month==\"05\")\n\nJan <- optimal_params_ns(uspar_jan$par,uspar_jan$maturity,n=1000,contraint_threshold = 0.25)\nFeb <- optimal_params_ns(uspar_feb$par,uspar_feb$maturity,n=1000,contraint_threshold = 0.25)\nMar <- optimal_params_ns(uspar_mar$par,uspar_mar$maturity,n=1000,contraint_threshold = 0.25)\nApr <- optimal_params_ns(uspar_apr$par,uspar_apr$maturity,n=1000,contraint_threshold = 0.25)\nMay <- optimal_params_ns(uspar_may$par,uspar_may$maturity,n=1000,contraint_threshold = 0.25)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nJan$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-pdf/unnamed-chunk-10-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nFeb$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-pdf/unnamed-chunk-10-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nMar$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-pdf/unnamed-chunk-10-3.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nApr$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-pdf/unnamed-chunk-10-4.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nMay$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-pdf/unnamed-chunk-10-5.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Problem 4\n\n위 문제에서 구한 모수값들을 가지고 6월 첫날의 금리커브를 예측하려고 한다. 모수값들에 대하여 적절한 (예: 엑셀에서 제공하는 선형 추세선을 찾아 사용) 예측값들을 구하고 이를 바탕으로 금리 커브를 구하시오.\n\n### Answer\n\n먼저, 문제3에서 최종적으로 산출한 NSS fitted curve에 대하여 각각의 파라미터는 아래와 같습니다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptim_parameters <- Jan$optim_params %>% \n  union_all(Feb$optim_params) %>% \n  union_all(Mar$optim_params) %>% \n  union_all(Apr$optim_params) %>% \n  union_all(May$optim_params) %>% \n  mutate(month=c(\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\"))\noptim_parameters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 7\n  beta0 beta1 beta2 beta3  tau1   tau2 month\n  <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl> <chr>\n1  2.35 3.35  -2.33  5.88 2.10  11.8   Jan  \n2  4.32 0.961 -3.16  1.34 2.06   0.127 Feb  \n3  3.32 2.30  -3.09  4.07 2.63  10.3   Mar  \n4  2.69 2.89  -3.15  6.44 3.45  11.7   Apr  \n5  3.46 2.05   1.74  4.09 0.802 14.1   May  \n```\n\n\n:::\n:::\n\n\n\n이를 이용하여 6월달의 US par-yield curve를 예측하고자 할 때, 모수값들을 활용하여 NSS모델의 6월 예상파라미터를 추정할 수 있습니다.\n\n여기에는 AR, ARMA, GARCH 등의 여러 모델을 생각할 수 있겠으나, 저는 직전 달의 모수값이 다음 달의 모수값에 대한 최적 추정치라고 생각합니다. 즉, **5월달의 NSS모델의 모수값을 6월의 예상파라미터**로 고려하겠습니다.\n\n이를 이용하여 산출한** 6월 예상 US par-yield 및 curve는 아래와 같습니다.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nest_jun <- tibble(maturity=uspar_may$maturity,\n                  par=May$df_optim$fit[[1]])\nest_jun\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 x 2\n   maturity   par\n      <dbl> <dbl>\n 1   0.0833  5.50\n 2   0.167   5.49\n 3   0.25    5.48\n 4   0.333   5.46\n 5   0.5     5.42\n 6   1       5.26\n 7   2       4.97\n 8   3       4.78\n 9   5       4.63\n10   7       4.62\n11  10       4.68\n12  20       4.80\n13  30       4.76\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(est_jun,aes(x=maturity,y=par))+\n  geom_line(colour=\"blue\", size=1)+\n  scale_x_continuous(breaks=c(0, 0.5, 1,2,3,4,5,7,10,15, 20, 25, 30))+\n  ggtitle(\"Expected US par-yield curve in June 1, based on NSS in May 1.\")+\n  xlab(\"Maturities\")+\n  ylab(\"\") + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Problem 5\n\nhw2.xlsx 에는 2011-10-28 부터 2016-10-28 까지의 스왑 데이터가 결측치가 있는 날들은 제외하고 들어 있다. 이를 이용하여 일별 금리변화를 주도하는 세 가지 주성분을 구하여 리포트하시오.\n\n### Answer",
    "supporting": [
      "이자율기간구조_hw2_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}