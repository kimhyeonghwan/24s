{
  "hash": "9d665fae2cb73a7a54323593e001ed05",
  "result": {
    "engine": "knitr",
    "markdown": "# 이자율기간구조 과제2 {.unnumbered}\n\n## Problem 1\n\n한 제조업체의 재무담당자가 usd 100 million 에 달하는 운전자본 working capital 을 3개월 정도 repo 시장에 투자하여 이익을 취하고자 한다.\n\n기간은 2020년 1월 15일(현재, 포함)에 시작하여 2020년 4월 15일(불포함)이 환매일이다. 즉 재무담당자는 91일 동안 daily SOFR 를 얻게 된다.\n\n그러나 최근 SOFR 의 하락세가 고민이 되어 투자금의 절반인 50 million 은 2020년 4월 만기인 3개월 SOFR 선물을 매수하여 수익 금리를 고정하는 효과를 가지려고 한다.\n\n기간 내내 금리가 1bp 하락한다면, act/360 기준으로 회사는 얼마의 손해가 발생하는가?\n\n이 절반에 대하여 SOFR 선물로 헤지를 한다면 몇 개의 선물 계약을 해야할지 본인의 계산을 쓰세요.\n\n### Answer\n\n전체 노출액 중 절반은 정확히 헷지하였으므로, 기간 중 노출액은 50mUSD입니다.\n\n노출기간은 91일이므로, **회사의 손해**는 $50,000,000\\times 0.0001\\times\\frac{91}{360}=1263.889USD$\n\nSOFR선물은 (100-r)로 호가하며, 1bp에 대해 25$만큼 변동합니다.\n\n따라서, 손실액만큼 SOFR선물에서 이익이 발생하도록 하려면 $\\frac{1263.889}{25}=50.56$, **약 51계약 매수**해야합니다.\n\n## Problem 2\n\n다음의 표는 2020년 6월 5일 ICE에서 가져온 usd스왑데이터이다. 편의상 각 스왑금리는 연 1회 지급한다고 하자. 우리는 bootstrapping 기법을 이용하여 이 스왑금리들을 할인율곡선 또는 현물이자율 곡선으로 변환할 수 있다.\n\n|구 분|1|2|3|4|5|6|\n|:---:|---:|---:|---:|---:|---:|---:|\n|Swap rate|0.307%|0.299%|0.346%|0.424%|0.517%|0.614%|\n\n이 문제에서는 그와 달리 매해 말 지급부담을 지니고 있는 은행 A를 고려한다. 이 은행은 현 시점에서 floating rate notes 변동금리부채권과 스왑을 매수하여 이 지급부담을 맞추려고 한다. 이때 변동금리부채권과 스왑의 액면값들을 구하는 것을 reverse bootstrapping이라 한다. 보다 정확히 다음의 구조를 고려하자.\n\n- 각 FRN은 $N_1, ... , N_6$의 액면을 가지고 있으며 이들은 i번째 해의 말까지 매년 $N_i$ 에 해당하는 변동금리를 지급하고 i번째 해의 말에는 액면 $N_i$ 도 지급한다.\n- 각 스왑의 액면 역시 $N_i$이며 A는 floating rate payer이다. 즉 i번째 해의 말까지 매년 $N_i$에 해당하는 변동금리를 거래상대방에게 지급한다. 역으로 거래상대방은 매해 말 $N_is_i$ 을 지불한다. 여기에서 $s_i$는 i 만기 스왑금리이다.\n\n$N_1,...,N_6$를 구하고 소수점 네째자리까지 리포트하시오.\n\n### Answer\n\n은행이 매년 1m\\$의 채무를 커버하기위해 1~6년 만기의 FRN을 $N_1\\sim N_6$만큼 매수하고, 여기에서 발생하는 변동금리이자분을 고정금리로 전환하기위해 Fixed-payer로 IRS를 동일한 명목금액 $N_1\\sim N_6$ 만큼 체결한다면, 매년 은행의 pay-off는 아래와 같습니다.\n\n|Year|FRN|IRS|Net|\n|:---:|---:|---:|---:|\n|1|$\\sum_{i=1}^6N_ir_i+N_1$|$\\sum_{i=1}^6(N_is_i-N_ir_i)$|$N_1+\\sum_{i=1}^6N_is_i$|\n|2|$\\sum_{i=2}^6N_ir_i+N_2$|$\\sum_{i=2}^6(N_is_i-N_ir_i)$|$N_2+\\sum_{i=2}^6N_is_i$|\n|3|$\\sum_{i=3}^6N_ir_i+N_3$|$\\sum_{i=3}^6(N_is_i-N_ir_i)$|$N_3+\\sum_{i=3}^6N_is_i$|\n|4|$\\sum_{i=4}^6N_ir_i+N_4$|$\\sum_{i=4}^6(N_is_i-N_ir_i)$|$N_4+\\sum_{i=4}^6N_is_i$|\n|5|$\\sum_{i=5}^6N_ir_i+N_5$|$\\sum_{i=5}^6(N_is_i-N_ir_i)$|$N_5+\\sum_{i=5}^6N_is_i$|\n|6|$N_6r_6+N_6$|$N_6s_6-N_6r_6$|$N_6+N_6s_6$|\n\n해당 pay-off에 따라 6년의 액면금액 $N_6$부터 reverse-bootstrapping방식으로 $N_i$를 모두 산출한 결과는 아래와 같습니다.\n\n|$N_1$|$N_2$|$N_3$|$N_4$|$N_5$|$N_6$|\n|:--:|:--:|:--:|:--:|:--:|:--:|\n|0.9753m|0.9783m|0.9812m|0.9846m|0.9888m|0.9939m|\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nswap <- swap %>% mutate(par=c(NA,NA,NA,NA,NA,c(1000000/(swap$rate[6]+1))))\nfor(i in 5:1){\n  swap$par[i]=(1000000-sum(swap$rate[(i+1):6]*swap$par[(i+1):6]))/(1+swap$rate[i])\n}\nswap\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  tenor    rate     par\n  <int>   <dbl>   <dbl>\n1     1 0.00307 975296.\n2     2 0.00299 978291.\n3     3 0.00346 981216.\n4     4 0.00424 984611.\n5     5 0.00517 988785.\n6     6 0.00614 993897.\n```\n\n\n:::\n:::\n\n\n\n\n## Problem 3\n\n미 재무부에서 발표하는 일별 par yield 데이터를 찾되, 2024년 1월부터 5월까지 매월 첫번째 일자의 커브를 구하시오. 그리고 이 5개의 금리 커브에 대하여 Nelson-Siegel-Svensson 모형을 적용하여 본인이 구한 최선의 fitted curve를 리포트하시오. 1개월 금리부터 30년 금리까지 데이터 전체를 활용하시오.\n\n여기서 정답은 없으니, 본인이 적절한 초기값 및 제약식을 넣어 문제를 푸세요.\n\n### Answer\n\n먼저, **미 재무부의 daily par yield** 데이터를 이용하여 산출한 매월 첫번째 일자의 커브는 아래와 같습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nuspar <- tibble()\nuspar <- read_csv(\"investment_hw/usparyield.csv\") %>% \n  arrange(Date) %>% \n  mutate(year=substr(Date,7,10),\n         month=substr(Date,1,2)) %>% \n  group_by(year,month) %>% \n  slice(1) %>% \n  pivot_longer(cols = contains(\" \"),values_to = \"par\", names_to = \"time\") %>% \n  mutate(maturity=c(1,2,3,4,6,12,24,36,60,84,120,240,360)/12) %>% \n  ungroup()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(uspar,aes(x=maturity,y=par,colour=month))+\n  geom_line()+\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n다음으로, **NSS모형을 이용한 최적 fitted curve**를 구해보겠습니다.\n\n::: {.callout-note title=\"Nelson-Siegel-Svensson Model\"}\nNSS모형은 instantaneous forword rate를 추정하는 대표적인 모형으로, 3개의 factor와 6개의 parameter($\\beta_0\\sim\\beta_3, \\tau_1\\sim\\tau_2$)를 이용합니다.\n\n$$f(t)=\\beta_0+\\beta_1e^{-\\frac{t}{\\tau_1}}+\\beta_2\\frac{t}{\\tau_1}e^{-\\frac{t}{\\tau1}}+\\beta_3\\frac{t}{\\tau_2}e^{-\\frac{t}{\\tau_2}}$$\n\n이를 통해 continuous-compounding spot rate curve를 추정할 수 있습니다.\n\n$$r(t)=\\beta_0+\\beta_1\\frac{1-e^{-\\frac{t}{\\tau_1}}}{\\frac{t}{\\tau_1}}+\\beta_2[\\frac{1-e^{-\\frac{t}{\\tau_1}}}{\\frac{t}{\\tau_1}}-e^{-\\frac{t}{\\tau_1}}]+\\beta_3[\\frac{1-e^{-\\frac{t}{\\tau_2}}}{\\frac{t}{\\tau_2}}-e^{-\\frac{t}{\\tau_2}}]$$\n:::\n\n저는 **최적 fitted curve를 시뮬레이션을 통해 산출**할 예정입니다.\n\n먼저, 초기값을 $\\beta_0=30y\\;\\;par\\;\\;rate,\\;\\;\\;\\beta_1=1m\\;\\;par\\;\\;rate-\\beta_0$ 및 $\\beta_{2,3},\\;\\tau_{1,2}$는 $(-5,\\;5)$ 범위의 Uniform dist. random number로 설정하겠습니다.\n\n해당 초기값에 따라 constraint condition을 기준금리의 변동폭을 고려하여 25bp, $|\\beta_0+\\beta_1-1m\\;\\;par\\;\\;rate|<0.25$로 설정하고 finite difference method(optim fn. in R)를 통해 최적해를 산출합니다.\n(tau와 beta는 별도의 제약식 없이 진행하였습니다.)\n\n이러한 방식을 1,000번 반복하는 Monte-carlo simulation을 통해 1,000개의 최적해를 산출하고, 1,000개의 NSS rate curve에서 MSE가 가장 낮은 curve를 최적 fitted curve로 선정하겠습니다.\n\n이를 구현하기 위한 **R코드 및 24년 1~5월의 fitted curve는 아래와 같습니다.**\n\n#### 1. NSS Model 함수\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (nelson_siegel) return NSS model rates for given parameters\n# maturity : vector of year maturity\n# params : vector of NSS medel 6 parameters, beta0 to tau2\n\nnelson_siegel <- function(maturity, params){\n  \n  # parameters \n  beta0 = params[1]\n  beta1 = params[2]\n  beta2 = params[3]\n  beta3 = params[4]\n  tau1  = params[5]\n  tau2  = params[6]\n  \n  # function \n  beta0 + \n    beta1 * (1 - exp(-maturity/tau1)) / (maturity/tau1) + \n    beta2 * ((1 - exp(-maturity/tau1)) / (maturity/tau1) - exp(-maturity/tau1)) + \n    beta3 * ((1 - exp(-maturity/tau2)) / (maturity/tau2) - exp(-maturity/tau2)) \n  \n}\n```\n:::\n\n\n#### 2. NSS 최적해 산출 함수(finite difference method)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (optim_nelson_siegel) return optimal tibble for given term-structure,\n#                       using finite difference method\n# maturity : vector of year maturity\n# term_sturucture : vector of real spot rate, order to maturity, omit %\n\noptim_nelson_siegel <- function(term_structure = NULL, maturity = NULL, params = rep(0.1, 6),\n                                contraint_threshold = 0.1, tau_threshold = 10, beta_threshold = 30){\n  \n  loss_function <- function(params){\n    \n    # parameters \n    beta0 = params[1]\n    beta1 = params[2]\n    beta2 = params[3]\n    beta3 = params[4]\n    tau1  = params[5]\n    tau2  = params[6]\n    \n    # contraints\n    contraint = abs(beta0 + beta1 - term_structure[1])\n    \n    if(contraint > contraint_threshold ){\n      return(NA)\n    }\n    \n    # if(tau1 > tau_threshold | tau2 > tau_threshold){\n    #   return(NA)\n    # }\n    # \n    # if(beta2 > beta_threshold | beta3 > beta_threshold ){\n    #   return(NA)\n    # }\n    \n    sum(\n      (term_structure - beta0 - \n         beta1 *  (1 - exp(-maturity/tau1)) / (maturity/tau1) -\n         beta2 * ((1 - exp(-maturity/tau1)) / (maturity/tau1) - exp(-maturity/tau1)) - \n         beta3 * ((1 - exp(-maturity/tau2)) / (maturity/tau2) - exp(-maturity/tau2)) \n      )^2)\n    \n  }\n  \n  # set initial values for to beta0 and beta1 that respect the contraint \n  # beta0 is long-term rate & beta1 is short-term rate minus beta0\n  params = c(term_structure[length(term_structure)],\n             term_structure[1]-term_structure[length(term_structure)],\n             params[3:6] )\n               \n  # beta0 & beta1 is equal to (short-term rate)/2\n  # params = c(term_structure[1]/2,term_structure[1]/2,params[3:6] )\n  \n  # minimization of the loss function \n  optimization = optim(params, loss_function)\n  \n  # optimal parameters \n  optim_params = c(beta0 = optimization$par[1], \n                   beta1 = optimization$par[2], \n                   beta2 = optimization$par[3],\n                   beta3 = optimization$par[4],\n                   tau1  = optimization$par[5], \n                   tau2  = optimization$par[6])\n  \n  # fitted value from Nelson-Siegel base function \n  fitted_values = nelson_siegel(maturity, optim_params)\n  \n  # compute the mean square error\n  mse_fit = sd(fitted_values - term_structure, na.rm = TRUE)\n  \n  # output \n  dplyr::tibble( \n    maturity = list(maturity),\n    term_structure = list(term_structure),\n    start_params = list(params),\n    optim_params = list(optim_params),\n    fit = list(fitted_values),\n    mse = mse_fit\n  )\n} \n```\n:::\n\n\n#### 3. Uniform dist. random number 생성\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (random_params) return random number follows an uniform distribution\n# n.params: number of parameter to generate \n# params.min: for random generation, minimum parameter\n# params.max: for random generation, maximum parameter\n# seed: to control randomness \n\nrandom_params <- function(n.params = 1, params.min = 0, params.max = 5, seed = 1){\n  \n  set.seed(seed)\n  \n  runif(n.params, params.min, params.max)\n  \n}\n```\n:::\n\n\n#### 4. Monte-carlo simulation (Calibration)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (calibrate_nelson_siegel) return n-times \"optim_nelson_siegel\" outputs\n#                           using Monte-carlo simulation for random 3 parameters(beta2 to tau2)\n# n: number of simulations \n# params.min: for random generation, minimum parameter\n# params.max: for random generation, maximum parameter\n# verbose: disply progress in the importation.\n\ncalibrate_nelson_siegel <- function(object, n = 100, params.min = -5, params.max = 5, \n                                    contraint_threshold = 0.01, verbose = TRUE ){\n  \n  # initialize the parameters \n  term_structure = object$term_structure[[1]]\n  maturity = object$maturity[[1]]\n  \n  # list containing all the simulations \n  simulations = list()\n  \n  # safe version to avoid errors if we made many simulations\n  safe_optim = purrr::safely(optim_nelson_siegel)\n  \n  for(i in 1:n){\n    \n    # generate a random seed\n    random_seed = mean(random_params(10, 0, 100000, seed = i))\n    \n    # generate random parameters \n    random_params = random_params(6, params.min, params.max, seed = random_seed)\n    \n    simulations[[i]] = safe_optim(term_structure  = term_structure, maturity = maturity, params = random_params, contraint_threshold = contraint_threshold)$result\n    \n    if( verbose &(i%%50 == 0)){message(\"Simulations: \", i, \"/\", n)}\n    \n  }\n  \n  # unique dataset for all the simulation\n  simulations_df = dplyr::bind_rows(simulations) \n  \n  # add the initial object\n  simulations_df = dplyr::bind_rows(object, simulations) \n  \n  # index for the simulations \n  simulations_df = dplyr::mutate(simulations_df, n = 1:nrow(simulations_df)) \n  \n  return(simulations_df)\n  \n}\n```\n:::\n\n\n#### 5. Optimal fitted curve 산출 및 시각화\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (optimal_params_ns) summarize of all above, return optimal result minimize MSE from n-times simulation.\n# term_structure = NULL\n# maturity = NULL\n# n = 1000\n# params.init = rep(0.1, 6)\n# params.min = -5\n# params.max = 5\n# contraint_threshold = 0.1\n# label = NULL (label for the plot)\n# verbose = TRUE\n\noptimal_params_ns <- function(term_structure = NULL, maturity = NULL, \n                              n = 1000, params.init = rep(0.1, 6), params.min = -5, params.max = 5,\n                              contraint_threshold = 0.1, label = NULL, verbose = TRUE){\n  \n  # first fit \n  first_fit_ns = optim_nelson_siegel(term_structure = term_structure, maturity = maturity, params = params.init)\n  \n  # simulations \n  sim_fit_ns = calibrate_nelson_siegel(first_fit_ns, n = n, params.min = params.min, params.max = params.max, contraint_threshold = contraint_threshold)\n  \n  # best parameters \n  df_optim_params = sim_fit_ns[which(sim_fit_ns$mse == min(sim_fit_ns$mse, na.rm = TRUE)),]\n  \n  \n  # setting the title of the plot \n  if(!is.null(label) & is.character(label)){\n    \n    plot_title = paste0(\"Fitted Nelson-Siegel-Svensonn vs Real Value \", \"(\", label, \")\" )\n    \n  } else {\n    \n    plot_title = \"Fitted Nelson-Siegel-Svensonn vs Real Value\"\n  }\n  \n  \n  # plot of fitted vs real values \n  plot_df =  dplyr::inner_join(\n    dplyr::tibble(\n      t = maturity,\n      pred = df_optim_params$fit[[1]]\n    ),\n    dplyr::tibble(\n      t = maturity,\n      real = term_structure\n    ),\n    by = \"t\"\n  ) \n  \n  # Plot Real value vs Fitted Values \n  plot_ns = plot_df %>%\n    mutate(label = paste0(\"T = \", round(t, 3)))%>%\n    ggplot()+\n    geom_point(aes(t, pred), color = \"red\", size = 2, alpha = 0.8) +\n    geom_point(aes(t, real), color = \"black\", alpha = 0.5)+\n    geom_line(aes(t, pred), color = \"red\", size = 1) +\n    geom_line(aes(t, real), color = \"black\", linetype = \"dashed\") +\n    geom_label(aes(t+1, real-0.001, label = label), size = 1.5)+\n    theme(axis.text.x = element_text(angle = 25, face = \"bold\", size = 7), \n          axis.text.y = element_text(face = \"bold\"), \n          axis.title  = element_text(face = \"bold\"),\n          plot.title  = element_text(face = \"bold\"),\n          plot.subtitle = element_text(face = \"italic\"),\n          plot.caption = element_text(face = \"italic\"),\n          panel.grid.major.x = element_line(colour=\"grey60\", linetype=\"dotted\"),\n          panel.grid.minor.x = element_blank(),\n          panel.grid.major.y = element_line(colour=\"grey60\", linetype=\"dotted\"),\n          legend.text = element_text(face = \"italic\", size = 5),\n          legend.title = element_text(face = \"bold\"),\n          legend.position = \"top\" ) +\n    scale_x_continuous(breaks=c(0, 0.5, 1,2,3,4,5,7,10,15, 20, 25, 30))+\n    ggtitle(plot_title, subtitle = \"Fitted Value in Red and Real Values in Black\" )+\n    xlab(\"Maturities\")+\n    ylab(\"\") + \n    labs(caption = paste0(\"Mean Squared Error of the Fit: \", round(df_optim_params$mse, 6)))+\n    theme_bw()\n  \n  \n  \n  # output \n  structure(\n    list(\n      optim_params = tibble( beta0=df_optim_params$optim_params[[1]][1],\n                             beta1=df_optim_params$optim_params[[1]][2],\n                             beta2=df_optim_params$optim_params[[1]][3],\n                             beta3=df_optim_params$optim_params[[1]][4],\n                             tau1=df_optim_params$optim_params[[1]][5],\n                             tau2=df_optim_params$optim_params[[1]][6]),\n      plot_ns = plot_ns,\n      simulations = sim_fit_ns,\n      df_optim = df_optim_params\n      \n    )\n  )\n  \n}\n```\n:::\n\n\n#### Result\n\n앞서 도식화한 **24년 1~5월의 US par-yield curve**에 위 방법을 적용하여 **각각 모델링한 fitted curve는 아래와 같습니다.**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nuspar_jan <- uspar %>% filter(month==\"01\")\nuspar_feb <- uspar %>% filter(month==\"02\")\nuspar_mar <- uspar %>% filter(month==\"03\")\nuspar_apr <- uspar %>% filter(month==\"04\")\nuspar_may <- uspar %>% filter(month==\"05\")\n\nJan <- optimal_params_ns(uspar_jan$par,uspar_jan$maturity,n=1000,contraint_threshold = 0.25)\nFeb <- optimal_params_ns(uspar_feb$par,uspar_feb$maturity,n=1000,contraint_threshold = 0.25)\nMar <- optimal_params_ns(uspar_mar$par,uspar_mar$maturity,n=1000,contraint_threshold = 0.25)\nApr <- optimal_params_ns(uspar_apr$par,uspar_apr$maturity,n=1000,contraint_threshold = 0.25)\nMay <- optimal_params_ns(uspar_may$par,uspar_may$maturity,n=1000,contraint_threshold = 0.25)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nJan$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\nFeb$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-html/unnamed-chunk-11-2.png){width=672}\n:::\n\n```{.r .cell-code}\nMar$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-html/unnamed-chunk-11-3.png){width=672}\n:::\n\n```{.r .cell-code}\nApr$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-html/unnamed-chunk-11-4.png){width=672}\n:::\n\n```{.r .cell-code}\nMay$plot_ns\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-html/unnamed-chunk-11-5.png){width=672}\n:::\n:::\n\n\n## Problem 4\n\n위 문제에서 구한 모수값들을 가지고 6월 첫날의 금리커브를 예측하려고 한다. 모수값들에 대하여 적절한 (예: 엑셀에서 제공하는 선형 추세선을 찾아 사용) 예측값들을 구하고 이를 바탕으로 금리 커브를 구하시오.\n\n### Answer\n\n먼저, 문제3에서 최종적으로 산출한 NSS fitted curve에 대하여 각각의 파라미터는 아래와 같습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\noptim_parameters <- Jan$optim_params %>% \n  union_all(Feb$optim_params) %>% \n  union_all(Mar$optim_params) %>% \n  union_all(Apr$optim_params) %>% \n  union_all(May$optim_params) %>% \n  mutate(month=c(\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\"))\noptim_parameters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 7\n  beta0 beta1 beta2 beta3  tau1   tau2 month\n  <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl> <chr>\n1  2.35 3.35  -2.33  5.88 2.10  11.8   Jan  \n2  4.32 0.961 -3.16  1.34 2.06   0.127 Feb  \n3  3.32 2.30  -3.09  4.07 2.63  10.3   Mar  \n4  2.69 2.89  -3.15  6.44 3.45  11.7   Apr  \n5  3.46 2.05   1.74  4.09 0.802 14.1   May  \n```\n\n\n:::\n:::\n\n\n이를 이용하여 6월달의 US par-yield curve를 예측하고자 할 때, 모수값들을 활용하여 NSS모델의 6월 예상파라미터를 추정할 수 있습니다.\n\n여기에는 AR, ARMA, GARCH 등의 여러 모델을 생각할 수 있겠으나, 저는 직전 달의 모수값이 다음 달의 모수값에 대한 최적 추정치라고 생각합니다. 모수값의 시계열자료가 5개에 불과하고, **특별한 선형관계나 추세가 관찰되지 않기 때문**입니다. 이에 따라 **5월달의 NSS모델의 모수값을 6월의 예상파라미터**로 고려하겠습니다.\n\n이를 이용하여 산출한 **6월 예상 US par-yield 및 curve는 아래와 같습니다.**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nest_jun <- tibble(maturity=uspar_may$maturity,\n                  par=May$df_optim$fit[[1]])\nest_jun\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 × 2\n   maturity   par\n      <dbl> <dbl>\n 1   0.0833  5.50\n 2   0.167   5.49\n 3   0.25    5.48\n 4   0.333   5.46\n 5   0.5     5.42\n 6   1       5.26\n 7   2       4.97\n 8   3       4.78\n 9   5       4.63\n10   7       4.62\n11  10       4.68\n12  20       4.80\n13  30       4.76\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(est_jun,aes(x=maturity,y=par))+\n  geom_line(colour=\"blue\", size=1)+\n  scale_x_continuous(breaks=c(0, 0.5, 1,2,3,4,5,7,10,15, 20, 25, 30))+\n  ggtitle(\"Expected US par-yield curve in June 1, based on NSS in May 1.\")+\n  xlab(\"Maturities\")+\n  ylab(\"\") + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n## Problem 5\n\nhw2.xlsx 에는 2011-10-28 부터 2016-10-28 까지의 스왑 데이터가 결측치가 있는 날들은 제외하고 들어 있다. 이를 이용하여 일별 금리변화를 주도하는 세 가지 주성분을 구하여 리포트하시오.\n\n### Answer\n\n먼저, 예제파일을 읽어와 일별/만기별 스왑금리의 차이를 bp단위로 계산하겠습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npca <- read_csv(\"investment_hw/term_hw2.csv\") %>% \n  pivot_longer(cols=contains(\"DSWP\"),names_to = \"maturity\", values_to = \"rate\") %>% \n  arrange(maturity,observation_date) %>% \n  mutate(changes=(rate-lag(rate))*100) %>% \n  filter(maturity==lag(maturity)) %>% \n  mutate(date=observation_date,\n         maturity=substr(maturity,5,nchar(maturity)) %>% as.integer()) %>% \n  select(date,maturity,changes)\n```\n:::\n\n\n다음으로, 각 만기별 covariance matrix를 산출하면 아래와 같습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncov_matrix <- pca %>% \n  pivot_wider(names_from = \"maturity\", values_from = \"changes\")\ncov_matrix <- cov_matrix[,2:ncol(cov_matrix)] %>% \n  select(`1`,`2`,`3`,`4`,`5`,`7`,`10`,`30`) %>% \n  cov()\n\noptions(digits=4)\ncov_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       1     2      3      4      5      7     10     30\n1  2.213 3.055  3.523  3.696  3.704  3.431  2.955  2.098\n2  3.055 5.697  7.042  7.839  8.177  8.046  7.338  5.748\n3  3.523 7.042  9.896 11.304 12.095 12.314 11.528  9.366\n4  3.696 7.839 11.304 13.825 14.949 15.678 15.021 12.600\n5  3.704 8.177 12.095 14.949 16.859 17.865 17.439 15.007\n7  3.431 8.046 12.314 15.678 17.865 20.054 20.057 18.130\n10 2.955 7.338 11.528 15.021 17.439 20.057 21.084 19.854\n30 2.098 5.748  9.366 12.600 15.007 18.130 19.854 21.117\n```\n\n\n:::\n:::\n\n\n이제, 공분산행렬을 통해 eigenvalue와 eigenvector를 계산하겠습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neigenstuff <- eigen(cov_matrix)\neigenstuff \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\neigen() decomposition\n$values\n[1] 97.7556  9.9072  1.7153  0.5056  0.2766  0.2129  0.1903  0.1832\n\n$vectors\n         [,1]     [,2]    [,3]     [,4]     [,5]     [,6]     [,7]     [,8]\n[1,] -0.08566 -0.28417  0.5080  0.59000  0.44064 -0.32532 -0.06279  0.04302\n[2,] -0.19278 -0.39768  0.4590  0.05126 -0.39712  0.61693  0.16366 -0.16203\n[3,] -0.28762 -0.39863  0.1332 -0.40842 -0.31307 -0.42430 -0.22186  0.49654\n[4,] -0.35997 -0.30873 -0.1546 -0.29835  0.19393 -0.30442  0.32447 -0.65316\n[5,] -0.40648 -0.19686 -0.3123 -0.04801  0.46000  0.44075 -0.53295  0.07933\n[6,] -0.44890  0.04588 -0.3212  0.29086  0.01963  0.06934  0.62949  0.45513\n[7,] -0.45266  0.28606 -0.1312  0.43332 -0.50253 -0.19855 -0.36367 -0.28993\n[8,] -0.41420  0.61983  0.5212 -0.34465  0.21905  0.04865  0.04712  0.03509\n```\n\n\n:::\n:::\n\n\n해당 **eigenvalue는 각 주성분의 설명력**을 나타냅니다. 각 eigenvalue의 전체 합에 대한 **비율은 전체 금리변화에서 해당 주성분이 설명하는 비율**을 나타냅니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neigenstuff$ratio=eigenstuff$values/sum(eigenstuff$values)\neigenstuff$ratio\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.882696 0.089458 0.015488 0.004565 0.002498 0.001922 0.001718 0.001654\n```\n\n\n:::\n:::\n\n\n이에 따르면, **첫번째 주성분이 약 88.3%, 두번째 주성분이 8.9%, 세번째 주성분이 1.5%를 설명**하고 있습니다. 이는 **3가지의 주성분만으로 전체 swap rate curve 변화의 약 98.8%를 설명**할 수 있다는 의미입니다.\n\n여기에서, **첫번째 주성분**은 **전체적인 금리수준의 변화(level change effect)**라고 할 수 있고 **두번째 주성분**은 **금리곡선의 기울기 변화(slope change effect)**, **세번째 주성분**은 **금리곡선의 볼록성 변화(convecture change effect)**라고 할 수 있습니다.\n\n세가지 주성분의 eigenvector를 도식화하면 아래와 같습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nplot_pca <- tibble(maturity=c(1:8),\n                   PC1=eigenstuff$vectors[,1],\n                   PC2=eigenstuff$vectors[,2],\n                   PC3=eigenstuff$vectors[,3]) %>% \n  pivot_longer(cols=contains(\"PC\"),names_to = \"components\", values_to = \"values\") %>% \n  ggplot(.,aes(x=maturity,y=values,colour=components))+\n  geom_line(size=1)+\n  theme_bw()\nplot_pca\n```\n\n::: {.cell-output-display}\n![](이자율기간구조_hw2_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::",
    "supporting": [
      "이자율기간구조_hw2_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}